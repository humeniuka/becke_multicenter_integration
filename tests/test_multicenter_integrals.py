#!/usr/bin/env python
# coding: utf-8
import unittest
import numpy as np
import numpy.linalg as la

from becke.MulticenterIntegration import multicenter_integration, multicenter_operation, multicenter_poisson, multicenter_laplacian, multicenter_grids, join_grids
from becke.MulticenterIntegration import atomlist2arrays
from becke.ERIs import electron_repulsion
from becke import GaussianIntegrals, GaussianBasis
from becke.CheckpointFile import G09ResultsDFT

def electron_density_function(orbs_alpha, orbs_beta, nelec_alpha, nelec_beta, basis):
    """assemble electron density from occupied orbitals"""
    # build density matrix
    occ_orbs_alpha = orbs_alpha[:,:nelec_alpha]
    occ_orbs_beta  = orbs_beta[:,:nelec_beta]
    Pa = np.dot(occ_orbs_alpha, occ_orbs_alpha.transpose())
    Pb = np.dot(occ_orbs_beta , occ_orbs_beta.transpose())
    P = Pa + Pb

    # overlap matrix
    S = GaussianIntegrals.basis_overlap(basis)
    electronic_charge = np.sum(S*P)

    def density(x,y,z):
        rho = 0.0*x
        for i in range(0, basis.nbfs):
            aoI = GaussianBasis.wavefunction(basis.exponents[i], basis.powers[:,i], basis.centers[:,i],
                                     x,y,z)
            for j in range(0, basis.nbfs):
                aoJ = GaussianBasis.wavefunction(basis.exponents[j], basis.powers[:,j], basis.centers[:,j],
                                            x,y,z)
                rho += P[i,j]*aoI*aoJ
        return rho

    return electronic_charge, density


class TestMulticenterIntegrals(unittest.TestCase):
    def test_hydrogen_1s_electrostatic_potential(self):
        """ 
        compute the electrostatic potential generated by an electron in a hydrogen 1s orbital

          psi(r) = 2/sqrt(4 pi) exp(-r)

        The exact result is

                 1 - exp(-2 r) (1+r)
          V(r) = -------------------
                        r
        """
        def rho_1s(x,y,z):
            """electron density of 1s hydrogen electron"""
            r = np.sqrt(x*x+y*y+z*z)
            rho = 1.0/np.pi * np.exp(-2*r)
            return rho
    
        atomic_coordinates = np.zeros((3,1))
        atomic_numbers = np.array([1])

        # grid settings
        rfac=2
        Lmax=23
    
        # Coulomb integral
        V1s = multicenter_poisson(rho_1s, atomic_coordinates, atomic_numbers,
                                  radial_grid_factor=rfac, lebedev_order=Lmax)

        # compare with exact solution on a slice along the x-axis
        r = np.linspace(1.0e-10, 10.0, 200)

        V1s_numer = V1s(r,0*r,0*r)
        V1s_exact = (1.0-np.exp(-2*r)*(1+r))/r

        self.assertLess( la.norm(V1s_numer - V1s_exact), 1.0e-3 )

        """
        # compare solutions visually
        import matplotlib.pyplot as plt
        plt.xlabel(r"r / $a_0$", fontsize=17)
        plt.ylabel(r"electrostatic potential $V_{1s}(r)$ / a.u.", fontsize=17)
        plt.plot(r, V1s_numer, "x", label="numerical solution")
        plt.plot(r, V1s_exact, lw=2, ls="-.", label="exact solution")

        plt.legend()
        plt.show()
        """

    def test_laplacian_hydrogen_1s(self):
        """
        compute the Laplacian for the 1s hydrogen wavefunction
        
          psi(r) = 2/sqrt(4 pi) exp(-r)

        The exact result is

          __2                             2
          \/  psi(r) = 2/sqrt(4 pi) (1 - --- ) exp(-r) 
                                          r
        """
        def psi_1s(x,y,z):
            """wavefunction of 1s hydrogen electron"""
            r = np.sqrt(x*x+y*y+z*z)
            psi = 1.0/np.sqrt(np.pi) * np.exp(-r)
            return psi
    
        atomic_coordinates = np.zeros((3,1))
        atomic_numbers = np.array([1])

        rfac=2
        Lmax=23
    
        # Laplacian
        lap_1s = multicenter_laplacian(psi_1s, atomic_coordinates, atomic_numbers,
                                       radial_grid_factor=rfac, lebedev_order=Lmax)

        # compare Laplacian along the x-axis
        r = np.linspace(1.0e-3, 10.0, 100000)
        lap_1s_numer = lap_1s(r,0*r,0*r)
        lap_1s_exact = 1/np.sqrt(np.pi) * (1.0-2.0/r)*np.exp(-r)

        self.assertLess(la.norm(lap_1s_numer - lap_1s_exact)/la.norm(lap_1s_exact), 1.0e-3)

        """
        # compare solutions visually
        import matplotlib.pyplot as plt
        plt.xlabel(r"r / $a_0$", fontsize=17)
        plt.ylabel(r"Laplacian $\nabla^2 \psi$ / a.u.", fontsize=17)

        plt.plot(r, lap_1s_numer, label="numerical solution")
        plt.plot(r, lap_1s_exact, lw=2, ls="-.", label="exact solution")

        plt.legend()
        plt.show()
        """

    def test_multicenter_laplacian(self):
        """
        compute the Laplacian of the LCAO wavefunction of the hydrogen
        molecule.
        """
        # bond length in bohr 
        R = 2.0
        # 
        atomlist = [(1, (0,0,-R/2.0)),
                    (1, (0,0,+R/2.0))]

        def psi_1s(x,y,z):
            """wavefunction of 1s hydrogen electron"""
            r = np.sqrt(x*x+y*y+z*z)
            psi = 1.0/np.sqrt(np.pi) * np.exp(-r)
            return psi

        def lap_1s(x,y,z):
            """analytical Laplacian for 1s orbital"""
            r = np.sqrt(x*x+y*y+z*z)
            lap = 1.0/np.sqrt(np.pi) * np.exp(-r) * (1 - 2.0/r)
            return lap
    
        def psi_sigma(x,y,z):
            """unnormalized LCAO wavefunction of H-H"""
            # sigma orbital is a linear combination of two
            # 1s orbitals of hydrogen
            psi = psi_1s(x,y,z-R/2.0) + psi_1s(x,y,z+R/2.0)
            return psi

        def lap_sigma_exact(x,y,z):
            """                       __2
            analytical expression for \/  psi_sigma
            """
            return lap_1s(x,y,z-R/2.0) + lap_1s(x,y,z+R/2.0)

        atomic_numbers, atomic_coordinates = atomlist2arrays(atomlist)

        # set radial and angular resolution of grid
        rfac=10
        Lmax=41
    
        # compute Laplacian on the grid
        lap_sigma = multicenter_laplacian(psi_sigma, atomic_coordinates, atomic_numbers,
                                          cusps_separate=False,
                                          radial_grid_factor=rfac, lebedev_order=Lmax)
        lap_sigma_cusps_separate = multicenter_laplacian(psi_sigma, atomic_coordinates, atomic_numbers,
                                                         cusps_separate=True,
                                                         radial_grid_factor=rfac, lebedev_order=Lmax)

        # compare Laplacian along the H-H bond (the z-axis)
        r = np.linspace(-10.0, 10.0, 100000)
        x, y, z = 0*r, 0*r, r

        exact = lap_sigma_exact(x,y,z)
        numer = lap_sigma(x,y,z)
        self.assertLess( la.norm( numer - exact ) / la.norm(exact), 1.0e-3 )

        numer_cusps_separate = lap_sigma_cusps_separate(x,y,z)
        self.assertLess( la.norm( numer_cusps_separate - exact ) / la.norm(exact), 1.0e-3 )

        """
        # compare solutions visually
        import matplotlib.pyplot as plt
        plt.xlabel("z / bohr", fontsize=17)
        
        plt.plot(r, psi_sigma(x,y,z), label=r"wavefunction $\psi_{\sigma}$")
        plt.plot(r, lap_sigma(x,y,z), label=r"$\nabla^2 \psi$, numerical solution")
        plt.plot(r, lap_sigma_cusps_separate(x,y,z), ls="-.", label=r"$\nabla^2 \psi$, numerical solution (cusps separate)")
        plt.plot(r, lap_sigma_exact(x,y,z), ls="--", label=r"$\nabla^2 \psi$, analytical solution")
        
        plt.legend()
        plt.show()
        """

    def test_multicenter_operations(self):
        """
        test addition of functions on the grid
        """
        atomlist = [(1, (0.0, 0.0, 0.0))]
        atomic_numbers, atomic_coordinates = atomlist2arrays(atomlist)
    
        def f(x,y,z):
            return np.sin(x+y+z)

        def g(x,y,z):
            return np.exp(-0.5 * (x**2 + y**2 + z**2))

        a = 0.3
        b = 0.7
    
        def h_test(x,y,z):
            return a*f(x,y,z) + b*g(x,y,z)

        rfac=3
        Lmax=23
        # h() = a*f() + b*g()
        h = multicenter_operation([f, g], lambda fs: a*fs[0]+b*fs[1], 
                                  atomic_coordinates, atomic_numbers,
                                  radial_grid_factor=rfac,
                                  lebedev_order=Lmax)

        # make random numbers reproducible
        np.random.seed(0)
        # check that h and h_test agree
        Npts = 100
        x = np.random.rand(Npts)
        y = np.random.rand(Npts)
        z = np.random.rand(Npts)
        
        err = la.norm( h(x,y,z) - h_test(x,y,z) )
        self.assertLess(err, 1.0e-3)
        
        #print( "error |h - h_test|= %e" % err )

    def test_join_grids(self):
        """
        check quadrature rule obtained by combining multicenter grids
        into a single grid
        """
        # set radial and angular resolution of grid
        rfac=10
        Lmax=21
        
        # bond length in bohr 
        R = 2.0
        # 
        atomlist = [(1, (0,0,-R/2.0)),
                    (1, (0,0,+R/2.0))]
        # spherical grids around each atom
        points, weights, volumes = multicenter_grids(atomlist,
                                                     radial_grid_factor=rfac,
                                                     lebedev_order=Lmax)
        # combine multicenter grids into a single grid
        x,y,z, w = join_grids(points, weights, volumes)

        sigma = 0.5
        def gauss(r):
            return 1.0/(np.sqrt(2*np.pi)*sigma) * np.exp(-0.5*(r/sigma)**2)

        def f(x,y,z):
            return gauss(x)*gauss(y)*gauss(z)

        # The 3d Gaussian function should be normalized
        gnorm = np.sum(w * f(x,y,z))

        #print( "norm of Gaussian = %e" % gnorm )
        self.assertLess( abs(gnorm-1.0), 1.0e-3 )

    def test_charge_from_numerical_integration(self):
        """
        compare the total electronic charge with the charge obtained by numerically
        integrating the electron density
        """
        # Formatted checkpoint files for water at the HF/SV level can be found in
        # tests/data/h2o_hf_sv.fchk.
        res = G09ResultsDFT('data/h2o_hf_sv.fchk')
        exact_charge, density = electron_density_function(res.orbs_alpha, res.orbs_beta,
                                                          res.nelec_alpha, res.nelec_beta, res.basis)

        integrated_charge = multicenter_integration(density, res.coordinates, res.atomic_numbers,
                                                    radial_grid_factor=4,
                                                    lebedev_order=23)
        
        self.assertLess( abs(integrated_charge-exact_charge), 1.0e-3 )


        # make table
        print( "" )
        print( "Lebedev order    radial grid factor         integrated charge" )
        print( "-------------------------------------------------------------" )

        for radial_grid_factor in [1,2,3,4]:
            for lebedev_order in [11, 17, 23]:
                integrated_charge = multicenter_integration(density, res.coordinates, res.atomic_numbers,
                                                            radial_grid_factor=radial_grid_factor,
                                                            lebedev_order=lebedev_order)
                print( "    %2.d                  %2.d                    %e" % (lebedev_order, radial_grid_factor, integrated_charge) )

        print( "        exact                                 %e" % exact_charge )

        
    def test_coulomb_integral_from_numerical_integration(self):
        """
        compute the classical Coulomb energy

                  / / rho(1) rho(2)                    /
          I = 1/2 | | ------------- d^3r1 d^3r2  = 1/2 | V(r) rho(r) d^3r
                  / /    r_12                          /

        for the total electron density rho using radial and angular grids of increasing
        resolution.

        Parameters
        ----------
        res         : instance of G09ResultsDFT with basis functions and orbital coefficients

        """
        # Formatted checkpoint files for water at the HF/SV level can be found in
        # tests/data/h2o_hf_sv.fchk. The classical Coulomb energies should
        # be compared with table II in ref. [2].
        res = G09ResultsDFT('data/h2o_hf_sv.fchk')
        exact_charge, density = electron_density_function(res.orbs_alpha, res.orbs_beta,
                                                          res.nelec_alpha, res.nelec_beta, res.basis)

        print( "" )
        print( "Lebedev order    radial grid factor       classical Coulomb energy   " )
        print( "---------------------------------------------------------------------" )

        for radial_grid_factor in [1,2,3,4]:
            for lebedev_order in [11, 17, 23]:
                # solve for the electrostatic potential generated by the charge density rho(r)
                elec_potential_func = multicenter_poisson(density, res.coordinates, res.atomic_numbers,
                                                          radial_grid_factor=radial_grid_factor,
                                                          lebedev_order=lebedev_order)
                def elec_energy_func(x,y,z):
                    return 0.5 * density(x,y,z) * elec_potential_func(x,y,z)

                en_elec = multicenter_integration(elec_energy_func, res.coordinates, res.atomic_numbers,
                                                  radial_grid_factor=radial_grid_factor,
                                                  lebedev_order=lebedev_order)
                print( "    %2.d                  %2.d                    %e" % (lebedev_order, radial_grid_factor, en_elec) )
        #
        # compute classical Coulomb energy from basis functions using analytical formulae
        # for electron repulsion integrals
        #
        basis = res.basis
        norms = np.zeros(basis.nbfs)
        for i in range(0, basis.nbfs):
            norms[i] = GaussianIntegrals.norm(basis.exponents[i], basis.powers[:,i])

        # build density matrix
        occ_orbs_alpha = res.orbs_alpha[:,:res.nelec_alpha]
        occ_orbs_beta  = res.orbs_beta[:,:res.nelec_beta]
        Pa = np.dot(occ_orbs_alpha, occ_orbs_alpha.transpose())
        Pb = np.dot(occ_orbs_beta , occ_orbs_beta.transpose())
        P = Pa + Pb

        # compute
        #
        #  I = 1/2 sum_{a,b,c,d} P_{a,b} (ab|cd) P_{c,d}
        #
        I = 0.0
        n = res.basis.nbfs
        for a in range(0, n):
            for b in range(0, n):
                for c in range(0, n):
                    for d in range(0, n):
                        abcd = GaussianIntegrals.coulomb_repulsion(
                            basis.centers[:,a], norms[a], basis.powers[:,a], basis.exponents[a],
                            basis.centers[:,b], norms[b], basis.powers[:,b], basis.exponents[b],
                            basis.centers[:,c], norms[c], basis.powers[:,c], basis.exponents[c],
                            basis.centers[:,d], norms[d], basis.powers[:,d], basis.exponents[d])
                        I += 0.5 * P[a,b] * abcd * P[c,d]

        print( "          exact                               %e" % I )

        self.assertLess( abs(en_elec - I), 1.0e-3 )        

    def test_electron_repulsion_integrals(self):
        """
        compare ERIs for Gaussian basis functions with analytical expressions
        """
        res = G09ResultsDFT('data/h2o_hf_sv.fchk')

        # molecular geometry
        atomlist = []
        for i in range(0, res.nat):
            atomlist.append( (res.atomic_numbers[i], res.coordinates[i,:]) )

        # factory for AO basis functions
        def wavefunction(exponent, powers, center):
            def wfn(x,y,z):
                return GaussianBasis.wavefunction(exponent, powers, center, x,y,z)
            return wfn

        basis = res.basis
        n = basis.nbfs
        # normalization factors
        norms = np.zeros(n)
        for i in range(0, n):
            norms[i] = GaussianIntegrals.norm(basis.exponents[i], basis.powers[:,i])

        print(" ERI            exact              numeric")
        print("-------------------------------------------")
        # loop over all combinations of basis functions, the 1s orbitals are left out as they
        # are too narrow for the radial grid. To speed up the test only 2 orbitals are selected
        aos = [2,3] # range(0, n)
        for a in aos:
            bfA = wavefunction(basis.exponents[a], basis.powers[:,a], basis.centers[:,a])
            for b in aos:
                bfB = wavefunction(basis.exponents[b], basis.powers[:,b], basis.centers[:,b])
                for c in aos:
                    bfC = wavefunction(basis.exponents[c], basis.powers[:,c], basis.centers[:,c])
                    for d in aos:
                        bfD = wavefunction(basis.exponents[d], basis.powers[:,d], basis.centers[:,d])
                        with self.subTest(eri=f"({a},{b}|{c},{d})"):
                            abcd = GaussianIntegrals.coulomb_repulsion(
                                basis.centers[:,a], norms[a], basis.powers[:,a], basis.exponents[a],
                                basis.centers[:,b], norms[b], basis.powers[:,b], basis.exponents[b],
                                basis.centers[:,c], norms[c], basis.powers[:,c], basis.exponents[c],
                                basis.centers[:,d], norms[d], basis.powers[:,d], basis.exponents[d])
                            abcd_numer = electron_repulsion(atomlist, bfA, bfB, bfC, bfD)
                            print(f"({a},{b}|{c},{d})    {abcd:+e}    {abcd_numer:+e}")
                            self.assertLess(abs(abcd - abcd_numer), 1.0e-3)
                        
        
    def test_h2_coulomb_exchange_integrals(self):
        """
        compute the Coulomb and exchange integrals

             (AA|BB), (AB|AB)

        for the hydrogen molecule H2 for a bond length of 1.40 bohr. The orbitals A and B
        are 1s hydrogen orbitals centered on either proton. The numbers from table I in 
        ref. [2] are reproduced. 
        """
        def hydrogen_1s(x,y,z):
            r = np.sqrt(x*x+y*y+z*z)
            psi = 2.0/np.sqrt(4.0*np.pi) * np.exp(-r)
            return psi
        # distance between the protons (in bohr)
        dist = 1.40
        #
        def rhoAB(x,y,z):
            # density of 1s orbital on nuclei A and B
            psiA = hydrogen_1s(x,y,z)
            psiB = hydrogen_1s(x,y,z-dist)
            return psiA*psiB
        def rhoAA(x,y,z):
            # density of 1s orbital on nucleus A
            psiA = hydrogen_1s(x,y,z)
            return psiA**2
        def rhoBB(x,y,z):
            # density of 1s orbital on nucleus B
            psiB = hydrogen_1s(x,y,z-dist)
            return psiB**2

        rfac=2
        Lmax=23

        atomic_coordinates = np.zeros((3,2))
        atomic_coordinates[2,1] = dist
        atomic_numbers = np.array([1,1])

        normA = multicenter_integration(rhoAA, atomic_coordinates, atomic_numbers,
                                        radial_grid_factor=rfac, lebedev_order=Lmax)
        print( "normalization (a|a)= %s" % normA )

        print( "hydrogen molecule H2" )
        print( "" )
        print( "         Integration Mesh                                                          " )
        print( "Lebedev order    radial grid factor       Coulomb (aa|bb)      Exchange (ab|ab)    " )
        print( "-----------------------------------------------------------------------------------" )

        for radial_grid_factor in [1,2,3,4]:
            for lebedev_order in [11, 17, 23]:
                # Coulomb integral
                Vbb = multicenter_poisson(rhoBB, atomic_coordinates, atomic_numbers,
                                          radial_grid_factor=radial_grid_factor,
                                          lebedev_order=lebedev_order)
                def Iaabb_integrand(x,y,z):
                    return rhoAA(x,y,z) * Vbb(x,y,z)
                Iaabb = multicenter_integration(Iaabb_integrand, atomic_coordinates, atomic_numbers,
                                                radial_grid_factor=radial_grid_factor,
                                                lebedev_order=lebedev_order)

                # exchange integral
                Vab = multicenter_poisson(rhoAB, atomic_coordinates, atomic_numbers,
                                          radial_grid_factor=radial_grid_factor,
                                          lebedev_order=lebedev_order)
                def Iabab_integrand(x,y,z):
                    return rhoAB(x,y,z) * Vab(x,y,z)
                Iabab = multicenter_integration(Iabab_integrand, atomic_coordinates, atomic_numbers,
                                                radial_grid_factor=radial_grid_factor,
                                                lebedev_order=lebedev_order)

                print( "    %2.d                  %2.d                  %.8f         %.8f" % (lebedev_order, radial_grid_factor, Iaabb, Iabab) )
        Iaabb_exact = 0.50352093
        Iabab_exact = 0.32329114
        print( "         exact                              %.8f         %.8f" % (Iaabb_exact, Iabab_exact) )

        self.assertLess( abs(Iaabb - Iaabb_exact), 1.0e-4 )
        self.assertLess( abs(Iabab - Iabab_exact), 1.0e-4 )
        
if __name__ == "__main__":
    unittest.main()

    
